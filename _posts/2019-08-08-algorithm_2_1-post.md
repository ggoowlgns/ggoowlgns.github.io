---
title:      "알고리즘 문제 해결 전략 : (2) 알고리즘 분석 - 시간 복잡도-2"
subtitle:   "Ch2 알고리즘 분석"
date:       2019-08-08
author:     "Park Ji Hoon"
header-img: "img/post_introducing_books/algorithm_1.jpg"
header-mask: 0.3
catalog:    True
tags:
    - 책 리뷰
    - 알고리즘 문제 해결 전략

---
> 알고리즘 평가의 꽃 시간복잡도(feat. 공간복잡도)

## 시간 복잡도
시간 복잡도(time complexity)란 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한것 (기본적인 연산 : 더 작게 쪼갤 수 없는 최소 크기의 연산)  
* 시간 복잡도가 높다 : 입력의 크기가 증가할때 수행 시간이 더 빠르게 증가한다. `즉, 시간 복잡도가 낮다고 항상 더 빠르게 동작하는것은 아님`  
* 입력의 종류에 따른 수행 시간 고려 (ex 선형 탐색)  
  * 최선의 수행 시간 (제일 처음에 찾는 값 : 1)
  * 최악의 수행 시간 (찾는 값이 없을때 : N)
  * 평균적인 경우의 수행시간 (평균 : N/2)

#### 점근적 시간 표기 : O()
대문자 O 표기법(Big-O Notation) : 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버림  
$$ ex)  f(N) = \frac 5 3N^2 - Nlg\frac N 2 + 16 N -7 $$
$$ f(N) = O(N^2)  
$$

| 문제 | 반복문의 수행 횟수 | O 표기|
|---- | -----------------| ------|
| $$movingAverage$$ | $$N$$ | $$O(N)$$ |
| $$binarySearch$$ | $$lgN$$ | $$O(lgN)$$ |
| $$selectMenu   (집합 덮개)$$ | $$NM2^M$$ | $$O(NM2^M)$$   `N, M미지수 but, 상수는 삭제` |
* $$f(N,M) = N^2M + NlgM + NM^2 = O(N^2M + NM^2)$$ `빠르게 증가하는 것만 살아남음 (N,M 둘중 어느쪽이 빠르게 증가하는건지 판단 불가)`
* $$f(N) = 42 = O(1)$$
